from pymongo import MongoClient
from bson import ObjectId, errors
from services.email_utils import send_result_email, send_interview_email
from fastapi import APIRouter, HTTPException, Query, Body, Form, UploadFile, File
from datetime import datetime
import os
import unicodedata
import re
import pdfplumber
import pytesseract
import pdf2image
import google.generativeai as genai
import json
from fastapi.responses import JSONResponse
from collections import defaultdict
from datetime import datetime, timedelta
from docx import Document

router = APIRouter()

# C·∫•u h√¨nh MongoDB
try:
    client = MongoClient("${import.meta.env.Mongo_connect}", serverSelectionTimeoutMS=3000)
    db = client["tuyendung"]
    collection = db["ung_vien"]
    jd_collection = db["mo_ta_cong_viec"]
    client.server_info()
    print("‚úÖ ƒê√£ k·∫øt n·ªëi MongoDB")
except Exception as e:
    print("‚ùå L·ªói k·∫øt n·ªëi MongoDB:", e)

# C·∫•u h√¨nh th∆∞ m·ª•c l∆∞u file v√† Gemini
UPLOAD_DIR = "cv_files"
os.makedirs(UPLOAD_DIR, exist_ok=True)
genai.configure(api_key="AIzaSyAVZplOCSPwJpdtnSeHfPDNstBze_gUZ2Y")  # Thay b·∫±ng API key c·ªßa b·∫°n

# H√†m chu·∫©n h√≥a t√™n file
def safe_filename(filename):
    filename = unicodedata.normalize('NFKD', filename).encode('ascii', 'ignore').decode('utf-8')
    filename = re.sub(r'[^\w\-_\. ]', '_', filename)
    name, ext = os.path.splitext(filename)
    timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    final_name = f"{name}_{timestamp}{ext}"  # T√™n l∆∞u tr·ªØ
    original_name = f"{name}{ext}"  # T√™n g·ªëc
    return original_name, final_name  # Tr·∫£ v·ªÅ c·∫£ hai

# H√†m ƒë·ªçc n·ªôi dung PDF
def pdf_to_text(pdf_path):
    try:
        with pdfplumber.open(pdf_path) as pdf:
            text = ""
            for page in pdf.pages:
                page_text = page.extract_text()
                if page_text:
                    page_text = unicodedata.normalize("NFKC", page_text)
                    page_text = re.sub(r'\n\s*\n', '\n', page_text)  # Lo·∫°i b·ªè d√≤ng tr·ªëng th·ª´a
                    page_text = re.sub(r"[^\x00-\x7F\u00C0-\u1EF9\n\s]", " ", page_text)
                    text += page_text + "\n"
            if text.strip():
                print("üìÑ N·ªôi dung PDF tr√≠ch xu·∫•t:", text)
                return text.strip()
    except Exception as e:
        print(f"‚ùå L·ªói pdfplumber: {e}")

    try:
        print("üì∏ ƒêang chuy·ªÉn PDF sang ·∫£nh ƒë·ªÉ OCR...")
        images = pdf2image.convert_from_path(pdf_path)
        text = ""
        for image in images:
            ocr_result = pytesseract.image_to_string(image, lang='vie+eng')
            ocr_result = unicodedata.normalize("NFKC", ocr_result)
            ocr_result = re.sub(r"[^\x00-\x7F\u00C0-\u1EF9\n\s]", " ", ocr_result)
            text += ocr_result + "\n"
        print("üìÑ N·ªôi dung OCR:", text)
        return text.strip()
    except Exception as e:
        print(f"‚ùå L·ªói OCR fallback: {e}")
        return ""

# H√†m ƒë·ªçc n·ªôi dung DOCX
def docx_to_text(docx_path):
    try:
        doc = Document(docx_path)
        text_parts = []
        for para in doc.paragraphs:
            if para.text.strip():
                text_parts.append(para.text.strip())
        for table in doc.tables:
            for row in table.rows:
                for cell in row.cells:
                    cell_text = cell.text.strip()
                    if cell_text:
                        text_parts.append(cell_text)
        return "\n".join(text_parts).strip()
    except Exception as e:
        print(f"‚ùå L·ªói ƒë·ªçc DOCX {docx_path}: {e}")
        return ""

# H√†m t√¨m JD ph√π h·ª£p
def select_matching_jd(position):
    try:
        jd = jd_collection.find_one({"vi_tri": position})
        if jd:
            print(f"üìå T√¨m th·∫•y JD kh·ªõp ch√≠nh x√°c: {jd['vi_tri']}")
            return jd

        jds = jd_collection.find({"vi_tri": {"$regex": re.escape(position), "$options": "i"}})
        best_jd = None
        best_score = 0
        position_lower = position.lower()

        for jd in jds:
            jd_position = jd.get("vi_tri", "").lower()
            common_length = len(set(position_lower.split()) & set(jd_position.split()))
            score = common_length / max(len(position_lower.split()), 1)
            if score > best_score:
                best_score = score
                best_jd = jd

        if best_jd and best_score > 0.5:
            print(f"üìå T√¨m th·∫•y JD g·∫ßn gi·ªëng: {best_jd['vi_tri']} (ƒëi·ªÉm kh·ªõp: {best_score})")
            return best_jd
        else:
            print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y JD ph√π h·ª£p cho v·ªã tr√≠: {position}")
            return None
    except Exception as e:
        print(f"‚ùå L·ªói khi t√¨m JD: {e}")
        return None

# H√†m tr√≠ch xu·∫•t th√¥ng tin b·ªï sung v·ªõi Gemini
def extract_info_with_gemini(text, filename, position, jd=None):
    jd_text = ""
    if jd:
        jd_text = f"""
        **M√¥ t·∫£ c√¥ng vi·ªác (JD)**:
        V·ªã tr√≠: {jd.get('vi_tri', '')}
        Y√™u c·∫ßu: {jd.get('mo_ta', '')}
        K·ªπ nƒÉng y√™u c·∫ßu: {', '.join(jd.get('ky_nang', []))}
        Ch·ª©ng ch·ªâ ∆∞u ti√™n: {', '.join(jd.get('chung_chi', []))}
        """

    prompt = f"""
    B·∫°n l√† AI chuy√™n gia tuy·ªÉn d·ª•ng. D·ª±a tr√™n CV v√† m√¥ t·∫£ c√¥ng vi·ªác (n·∫øu c√≥), h√£y tr√≠ch xu·∫•t c√°c th√¥ng tin b·ªï sung theo m·∫´u JSON sau. Ch·ªâ tr√≠ch xu·∫•t c√°c tr∆∞·ªùng ƒë∆∞·ª£c y√™u c·∫ßu, b·ªè qua c√°c tr∆∞·ªùng ƒë√£ ƒë∆∞·ª£c cung c·∫•p t·ª´ form (ho_ten, email, so_dien_thoai, vi_tri_ung_tuyen, ngay_sinh, que_quan, noi_o).

    **M·∫´u JSON**:
    {{
      "trinh_do_hoc_van": [],
      "kinh_nghiem": [],
      "ky_nang": [],
      "chung_chi": [],
      "giai_thuong": [],
      "du_an": [],
      "muc_tieu_nghe_nghiep": "",
      "so_thich": [],
      "nguoi_gioi_thieu": [],
      "hoat_dong": [],
      "diem_phu_hop": 0,
      "nhan_xet": ""
    }}

    **Y√™u c·∫ßu ƒë·ªãnh d·∫°ng**:
    - C√°c tr∆∞·ªùng `trinh_do_hoc_van`, `kinh_nghiem`, `ky_nang`, `chung_chi`, `giai_thuong`, `du_an`, `so_thich`, `nguoi_gioi_thieu`, `hoat_dong` ph·∫£i l√† danh s√°ch c√°c CHU·ªñI (string), KH√îNG ph·∫£i object.
    - **Chi ti·∫øt y√™u c·∫ßu**:
      - `trinh_do_hoc_van`: L·∫•y b·∫±ng c·∫•p, chuy√™n ng√†nh, tr∆∞·ªùng v√† nƒÉm t·ªët nghi·ªáp (n·∫øu c√≥). V√≠ d·ª•: ["C·ª≠ nh√¢n CNTT ƒê·∫°i h·ªçc B√°ch khoa H√† N·ªôi 2010"].
      - `kinh_nghiem`: L·∫•y v·ªã tr√≠ c√¥ng vi·ªác, c√¥ng ty, th·ªùi gian v√† m√¥ t·∫£ ng·∫Øn g·ªçn nhi·ªám v·ª•. V√≠ d·ª•: ["Network Engineer t·∫°i Viettel 2018-2020: C·∫•u h√¨nh router Cisco"].
      - `ky_nang`: L·∫•y c√°c k·ªπ nƒÉng k·ªπ thu·∫≠t ho·∫∑c m·ªÅm. V√≠ d·ª•: ["Python", "Teamwork"].
      - `chung_chi`: L·∫•y t√™n ch·ª©ng ch·ªâ, nƒÉm v√† t·ªï ch·ª©c c·∫•p (n·∫øu c√≥). V√≠ d·ª•: ["TOEIC 900 2023", "AWS Certified 2022"].
      - `giai_thuong`: L·∫•y t√™n gi·∫£i th∆∞·ªüng, nƒÉm v√† t·ªï ch·ª©c/s·ª± ki·ªán. V√≠ d·ª•: ["Gi·∫£i nh·∫•t Hackathon 2023"].
      - `du_an`: L·∫•y t√™n d·ª± √°n, c√¥ng ty, nƒÉm v√† m√¥ t·∫£ ng·∫Øn g·ªçn nhi·ªám v·ª•, g·ªôp th√†nh m·ªôt chu·ªói. V√≠ d·ª•: ["X√¢y d·ª±ng m·∫°ng n·ªôi b·ªô cho trung t√¢m d·ªØ li·ªáu t·∫°i IDC Vi·ªát Nam 2023: C·∫•u h√¨nh BGP, OSPF, Firewall ƒëa l·ªõp"].
      - `so_thich`: L·∫•y s·ªü th√≠ch c√° nh√¢n. V√≠ d·ª•: ["T·∫≠p gym", "Tham gia hackathon"].
      - `nguoi_gioi_thieu`: L·∫•y t√™n, v·ªã tr√≠, c√¥ng ty, email v√† s·ªë ƒëi·ªán tho·∫°i (n·∫øu c√≥). V√≠ d·ª•: ["Nguy·ªÖn VƒÉn A - Manager t·∫°i Viettel - a@viettel.vn - 0123456789"].
      - `hoat_dong`: L·∫•y vai tr√≤, t·ªï ch·ª©c, th·ªùi gian v√† m√¥ t·∫£ ng·∫Øn g·ªçn. V√≠ d·ª•: ["Tr∆∞·ªüng ban C√¢u l·∫°c b·ªô Kh·ªüi nghi·ªáp 2018-2020: T·ªï ch·ª©c workshop"].
    - N·∫øu kh√¥ng t√¨m th·∫•y th√¥ng tin, ƒë·ªÉ danh s√°ch r·ªóng (`[]`) ho·∫∑c chu·ªói r·ªóng (`""`).

    **VƒÉn b·∫£n CV**:
    {text}

    {jd_text}

    **L∆∞u √Ω**:
    - Ch·ªâ tr·∫£ v·ªÅ ƒë√∫ng JSON, kh√¥ng th√™m m√¥ t·∫£ ngo√†i.
    - `diem_phu_hop` (0‚Äì100): T√≠nh d·ª±a tr√™n m·ª©c ƒë·ªô ph√π h·ª£p gi·ªØa CV v√† JD (n·∫øu c√≥). So s√°nh k·ªπ nƒÉng, kinh nghi·ªám, ch·ª©ng ch·ªâ, v√† d·ª± √°n trong CV v·ªõi y√™u c·∫ßu JD. N·∫øu kh√¥ng c√≥ JD, tr·∫£ v·ªÅ 0.
    - `nhan_xet`: N√™u ƒëi·ªÉm m·∫°nh/y·∫øu c·ªßa CV so v·ªõi JD (n·∫øu c√≥) v√† g·ª£i √Ω c·∫£i thi·ªán. N·∫øu kh√¥ng c√≥ JD, ch·ªâ nh·∫≠n x√©t chung v·ªÅ CV.
    - Tr√≠ch xu·∫•t ƒë·∫ßy ƒë·ªß v√† chi ti·∫øt t·∫•t c·∫£ c√°c tr∆∞·ªùng, ƒë·∫∑c bi·ªát l√† `du_an`, g·ªôp th√¥ng tin th√†nh chu·ªói duy nh·∫•t.
    """
    try:
        model = genai.GenerativeModel("gemini-1.5-flash")
        response = model.generate_content(prompt)
        raw_json = response.text.strip()
        if "```" in raw_json:
            raw_json = [part for part in raw_json.split("```") if "{" in part][0]
        match = re.search(r"\{.*\}", raw_json, re.DOTALL)
        if not match:
            print("‚ùå Kh√¥ng t√¨m th·∫•y JSON h·ª£p l·ªá")
            return None
        result = json.loads(match.group())

        # X·ª≠ l√Ω c√°c danh s√°ch ƒë·ªÉ ƒë·∫£m b·∫£o ch·ªâ ch·ª©a chu·ªói
        list_fields = [
            "trinh_do_hoc_van", "kinh_nghiem", "ky_nang", "chung_chi",
            "giai_thuong", "du_an", "so_thich", "nguoi_gioi_thieu", "hoat_dong"
        ]
        for field in list_fields:
            if field in result and isinstance(result[field], list):
                result[field] = [
                    str(item) if isinstance(item, str) else f"{item.get('name', '')} {item.get('year', '')} {item.get('score', '')}".strip()
                    for item in result[field]
                ]
                result[field] = [item for item in result[field] if item]

        print("üìú Th√¥ng tin tr√≠ch xu·∫•t t·ª´ Gemini:", result)
        return result
    except Exception as e:
        print(f"‚ùå L·ªói khi g·ªçi Gemini: {e}")
        return None

# Endpoint GET danh s√°ch ·ª©ng vi√™n
@router.get("/")
def get_candidates():
    try:
        print("üîó ƒêang truy v·∫•n d·ªØ li·ªáu ·ª©ng vi√™n")
        docs = collection.find({"ho_ten": {"$ne": ""}})
        result = []
        for doc in docs:
            doc["id"] = str(doc["_id"])
            del doc["_id"]
            result.append(doc)
        print("üìä D·ªØ li·ªáu tr·∫£ v·ªÅ t·ª´ GET /candidates/:", result)
        return result
    except Exception as e:
        print("‚ùå L·ªói khi truy v·∫•n Mongo:", e)
        return {"error": str(e)}

# Endpoint POST ƒë·ªÉ th√™m ·ª©ng vi√™n m·ªõi
@router.post("/")
async def add_candidate(
    ho_ten: str = Form(...),
    email: str = Form(...),
    so_dien_thoai: str = Form(...),
    vi_tri_ung_tuyen: str = Form(...),
    ngay_sinh: str = Form(None),
    que_quan: str = Form(None),
    noi_o: str = Form(None),
    cv_file: UploadFile = File(None),
):
    try:
        cv_filepath = ""
        info = None

        # T√¨m JD ph√π h·ª£p
        jd = select_matching_jd(vi_tri_ung_tuyen)

        # X·ª≠ l√Ω file CV n·∫øu c√≥
        if cv_file:
            file_extension = cv_file.filename.lower().split(".")[-1]
            if file_extension not in ["pdf", "docx", "doc"]:
                raise HTTPException(status_code=400, detail="Ch·ªâ ch·∫•p nh·∫≠n file PDF ho·∫∑c Word (DOCX)")
            
            if cv_file.size > 5 * 1024 * 1024:
                raise HTTPException(status_code=400, detail="File v∆∞·ª£t qu√° 5MB")

            # L·∫•y c·∫£ t√™n g·ªëc v√† t√™n l∆∞u tr·ªØ
            original_filename, storage_filename = safe_filename(cv_file.filename)
            cv_filepath = os.path.join(UPLOAD_DIR, original_filename).replace("\\", "/")  # L∆∞u t√™n g·ªëc
            storage_path = os.path.join(UPLOAD_DIR, storage_filename).replace("\\", "/")  # ƒê∆∞·ªùng d·∫´n l∆∞u tr·ªØ th·ª±c t·∫ø
            with open(storage_path, "wb") as f:
                f.write(await cv_file.read())

            print(f"üìÇ cv_filepath (t√™n g·ªëc): {cv_filepath}")  # Log ƒë·ªÉ debug
            print(f"üìÇ storage_path (t√™n l∆∞u tr·ªØ): {storage_path}")  # Log ƒë·ªÉ debug

            # Tr√≠ch xu·∫•t n·ªôi dung t·ª´ file
            text = ""
            if file_extension == "pdf":
                text = pdf_to_text(storage_path)
            elif file_extension in ["docx", "doc"]:
                text = docx_to_text(storage_path)
            
            if not text:
                print("‚ö†Ô∏è Kh√¥ng tr√≠ch xu·∫•t ƒë∆∞·ª£c n·ªôi dung t·ª´ file")

            # Tr√≠ch xu·∫•t th√¥ng tin b·ªï sung v·ªõi Gemini
            info = extract_info_with_gemini(text, cv_file.filename, vi_tri_ung_tuyen, jd) if text else None

        # T·∫°o document cho MongoDB
        new_candidate = {
            "ho_ten": ho_ten,
            "email": email,
            "so_dien_thoai": so_dien_thoai,
            "vi_tri_ung_tuyen": vi_tri_ung_tuyen,
            "ngay_sinh": ngay_sinh,
            "que_quan": que_quan,
            "noi_o": noi_o,
            "trinh_do_hoc_van": info.get("trinh_do_hoc_van", []) if info else [],
            "kinh_nghiem": info.get("kinh_nghiem", []) if info else [],
            "ky_nang": info.get("ky_nang", []) if info else [],
            "chung_chi": info.get("chung_chi", []) if info else [],
            "giai_thuong": info.get("giai_thuong", []) if info else [],
            "du_an": info.get("du_an", []) if info else [],
            "trang_thai": "ƒêang ·ª©ng tuy·ªÉn",
            "ngay_nop": datetime.now(),
            "diem_phu_hop": info.get("diem_phu_hop", 0) if info else 0,
            "nhan_xet": info.get("nhan_xet", "") if info else "",
            "cv_filepath": cv_filepath,
            "muc_tieu_nghe_nghiep": info.get("muc_tieu_nghe_nghiep", "") if info else "",
            "so_thich": info.get("so_thich", []) if info else [],
            "nguoi_gioi_thieu": info.get("nguoi_gioi_thieu", []) if info else [],
            "hoat_dong": info.get("hoat_dong", []) if info else []
        }

        # L∆∞u v√†o MongoDB
        result = collection.insert_one(new_candidate)

        # Truy v·∫•n l·∫°i ƒë·ªÉ l·∫•y document ƒë√£ insert
        doc = collection.find_one({"_id": result.inserted_id})
        doc["id"] = str(doc["_id"])
        del doc["_id"]

        # In danh s√°ch d·ª± √°n
        print("D·ª± √°n        :")
        du_an_list = doc.get("du_an", [])

        if not isinstance(du_an_list, list):
            du_an_list = [du_an_list]  # Bi·∫øn th√†nh list d√π ban ƒë·∫ßu l√† chu·ªói ho·∫∑c None

        for d in du_an_list:
            print(f"  - {d}")

        print("üì¶ Document l∆∞u v√†o MongoDB:", doc)

        # X√≥a file t·∫°m
        if storage_path and os.path.exists(storage_path):
            os.remove(storage_path)
            print(f"üóëÔ∏è ƒê√£ x√≥a file t·∫°m: {storage_path}")

        return doc

    except Exception as e:
        print("‚ùå L·ªói th√™m ·ª©ng vi√™n:", e)
        raise HTTPException(status_code=500, detail="Kh√¥ng th·ªÉ th√™m ·ª©ng vi√™n")


@router.get("/interviews")
def get_all_interviews():
    try:
        # Th√™m log ƒë·ªÉ debug
        print("üìã ƒêang truy v·∫•n l·ªãch ph·ªèng v·∫•n t·ª´ database...")
        
        docs = collection.find({
            "lich_phong_van.ngay": {"$exists": True, "$ne": ""},
            "lich_phong_van.gio": {"$exists": True, "$ne": ""},
            "lich_phong_van.dia_diem": {"$exists": True, "$ne": ""}
        })

        result = []
        for doc in docs:
            lich = doc.get("lich_phong_van", {})
            result.append({
                "id": str(doc["_id"]),
                "candidate": doc.get("ho_ten", "Kh√¥ng t√™n"),
                "date": lich.get("ngay", ""),
                "time": lich.get("gio", ""),
                "room": lich.get("dia_diem", "")
            })
        
        print(f"‚úÖ T√¨m th·∫•y {len(result)} l·ªãch ph·ªèng v·∫•n")
        return result
    except Exception as e:
        print(f"‚ùå L·ªói khi truy v·∫•n l·ªãch ph·ªèng v·∫•n: {e}")
        # Tr·∫£ v·ªÅ l·ªói v·ªõi status code 500
        from fastapi import HTTPException
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/potential")
def get_potential_candidates(position: str = Query(...)):
    # T√¨m ·ª©ng vi√™n c√≥ v·ªã tr√≠ ƒë√∫ng (kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng)
    query = {
        "vi_tri_ung_tuyen": { "$regex": f"^{position}$", "$options": "i" }
    }

    # S·∫Øp x·∫øp theo ƒëi·ªÉm t·ª´ cao xu·ªëng
    docs = list(collection.find(query).sort("diem_phu_hop", -1))

    # Convert ObjectId -> string
    for doc in docs:
        doc["id"] = str(doc["_id"])
        del doc["_id"]
    return docs

@router.get("/potential-positions")
def get_valid_candidate_positions():
    jd_positions = db["mo_ta_cong_viec"].distinct("vi_tri")
    jd_positions_lower = [p.lower() for p in jd_positions if isinstance(p, str)]

    # So s√°nh kh√¥ng ph√¢n bi·ªát hoa th∆∞·ªùng
    candidate_positions = db["ung_vien"].distinct("vi_tri_ung_tuyen")
    valid = [p for p in candidate_positions if isinstance(p, str) and p.lower() in jd_positions_lower]

    return sorted(valid)

@router.post("/schedule-interview")
def schedule_interview(
    data: dict = Body(...)
):
    try:
        print(f"üìù Nh·∫≠n d·ªØ li·ªáu ƒë·∫∑t l·ªãch: {data}")
        
        candidate_ids = data.get("candidateIds", [])
        interview_date = data.get("date")
        interview_time = data.get("time")
        interview_location = data.get("location")
        
        print(f"üìå Th√¥ng tin ƒë·∫∑t l·ªãch: {len(candidate_ids)} ·ª©ng vi√™n, ng√†y: {interview_date}, gi·ªù: {interview_time}, ƒë·ªãa ƒëi·ªÉm: {interview_location}")
        
        if not candidate_ids or not interview_date or not interview_time or not interview_location:
            print("‚ùå Thi·∫øu th√¥ng tin c·∫ßn thi·∫øt")
            raise HTTPException(status_code=400, detail="Thi·∫øu th√¥ng tin c·∫ßn thi·∫øt")
        
        # T·∫°o ƒë·ªëi t∆∞·ª£ng datetime t·ª´ date v√† time
        try:
            interview_datetime = datetime.strptime(f"{interview_date} {interview_time}", "%Y-%m-%d %H:%M")
            print(f"‚úÖ Th·ªùi gian ph·ªèng v·∫•n h·ª£p l·ªá: {interview_datetime}")
        except ValueError as e:
            print(f"‚ùå ƒê·ªãnh d·∫°ng ng√†y gi·ªù kh√¥ng h·ª£p l·ªá: {e}")
            raise HTTPException(status_code=400, detail=f"ƒê·ªãnh d·∫°ng ng√†y gi·ªù kh√¥ng h·ª£p l·ªá: {str(e)}")
        
        # Ki·ªÉm tra xem collection c√≥ t·ªìn t·∫°i kh√¥ng
        print(f"üìä Ki·ªÉm tra collection: {collection}")
        
        # Chuy·ªÉn ƒë·ªïi c√°c ID th√†nh ObjectId
        object_ids = []
        for id_str in candidate_ids:
            try:
                object_id = ObjectId(id_str)
                object_ids.append(object_id)
                print(f"‚úÖ ID h·ª£p l·ªá: {id_str}")
            except errors.InvalidId:
                print(f"‚ùå ID kh√¥ng h·ª£p l·ªá: {id_str}")
                continue
        
        if not object_ids:
            print("‚ùå Kh√¥ng c√≥ ID ·ª©ng vi√™n h·ª£p l·ªá")
            raise HTTPException(status_code=400, detail="Kh√¥ng c√≥ ID ·ª©ng vi√™n h·ª£p l·ªá")
        
        # T√¨m c√°c ·ª©ng vi√™n ƒë∆∞·ª£c ch·ªçn
        print(f"üîç T√¨m ki·∫øm {len(object_ids)} ·ª©ng vi√™n trong database")
        candidates = list(collection.find({"_id": {"$in": object_ids}}))
        print(f"‚úÖ T√¨m th·∫•y {len(candidates)} ·ª©ng vi√™n")
        
        # Ph√¢n lo·∫°i ·ª©ng vi√™n
        valid_candidates = []
        invalid_candidates = []
        
        for candidate in candidates:
            candidate_name = candidate.get("ho_ten", "Kh√¥ng t√™n")
            candidate_result = candidate.get("ket_qua", "Ch∆∞a c√≥ k·∫øt qu·∫£")
            print(f"üë§ Ki·ªÉm tra ·ª©ng vi√™n {candidate_name}, k·∫øt qu·∫£ CV: {candidate_result}")
            
            # Ch·ªâ ƒë·∫∑t l·ªãch cho ·ª©ng vi√™n ƒë√£ qua v√≤ng CV (k·∫øt qu·∫£ l√† "Pass")
            if candidate.get("ket_qua") == "Pass":
                valid_candidates.append(candidate)
                print(f"‚úÖ ·ª®ng vi√™n {candidate_name} ƒë·ªß ƒëi·ªÅu ki·ªán")
            else:
                invalid_candidates.append(candidate)
                print(f"‚ùå ·ª®ng vi√™n {candidate_name} kh√¥ng ƒë·ªß ƒëi·ªÅu ki·ªán (k·∫øt qu·∫£: {candidate_result})")
        
        if not valid_candidates:
            print("‚ùå Kh√¥ng c√≥ ·ª©ng vi√™n n√†o ƒë·ªß ƒëi·ªÅu ki·ªán ƒë·ªÉ ƒë·∫∑t l·ªãch ph·ªèng v·∫•n")
            return {
                "success": False,
                "message": "Kh√¥ng c√≥ ·ª©ng vi√™n n√†o ƒë·ªß ƒëi·ªÅu ki·ªán ƒë·ªÉ ƒë·∫∑t l·ªãch ph·ªèng v·∫•n. Vui l√≤ng ch·ªçn ·ª©ng vi√™n ƒë√£ Pass CV."
            }
        
        valid_ids = [candidate["_id"] for candidate in valid_candidates]
        
        # C·∫≠p nh·∫≠t th√¥ng tin l·ªãch ph·ªèng v·∫•n cho c√°c ·ª©ng vi√™n h·ª£p l·ªá
        print(f"üìù C·∫≠p nh·∫≠t l·ªãch ph·ªèng v·∫•n cho {len(valid_candidates)} ·ª©ng vi√™n")
        try:
            update_result = collection.update_many(
                {"_id": {"$in": valid_ids}},
                {"$set": {
                    "lich_phong_van": {
                        "ngay": interview_date,
                        "gio": interview_time,
                        "dia_diem": interview_location,
                        "trang_thai": "ƒê√£ l√™n l·ªãch"
                    },
                    "trang_thai": "Ch·ªù ph·ªèng v·∫•n"  # C·∫≠p nh·∫≠t tr·∫°ng th√°i ·ª©ng vi√™n
                }}
            )
            print(f"‚úÖ ƒê√£ c·∫≠p nh·∫≠t {update_result.modified_count} ·ª©ng vi√™n")
        except Exception as e:
            print(f"‚ùå L·ªói khi c·∫≠p nh·∫≠t database: {str(e)}")
            import traceback
            print(traceback.format_exc())
            raise HTTPException(status_code=500, detail=f"L·ªói khi c·∫≠p nh·∫≠t th√¥ng tin: {str(e)}")
        
        # G·ª≠i email th√¥ng b√°o l·ªãch ph·ªèng v·∫•n cho ·ª©ng vi√™n h·ª£p l·ªá
        email_success = []
        email_failed = []
        
        for candidate in valid_candidates:
            email = candidate.get("email")
            ho_ten = candidate.get("ho_ten", "·ª®ng vi√™n")
            
            if not email:
                print(f"‚ö†Ô∏è ·ª®ng vi√™n {ho_ten} kh√¥ng c√≥ email")
                email_failed.append(f"{ho_ten} (kh√¥ng c√≥ email)")
                continue
                
            try:
                print(f"üìß G·ª≠i email th√¥ng b√°o ƒë·∫øn {ho_ten} ({email})")
                send_interview_email(
                    email,
                    ho_ten,
                    interview_date,
                    interview_time,
                    interview_location
                )
                email_success.append(ho_ten)
                print(f"‚úÖ ƒê√£ g·ª≠i email cho {ho_ten}")
            except Exception as e:
                print(f"‚ùå L·ªói g·ª≠i email cho {ho_ten} ({email}): {str(e)}")
                import traceback
                print(traceback.format_exc())
                email_failed.append(f"{ho_ten} ({str(e)})")
        
        # Chu·∫©n b·ªã th√¥ng b√°o
        message = f"ƒê√£ ƒë·∫∑t l·ªãch ph·ªèng v·∫•n cho {len(valid_candidates)} ·ª©ng vi√™n."
        
        if email_success:
            message += f"\n\nƒê√£ g·ª≠i email th√¥ng b√°o ƒë·∫øn {len(email_success)} ·ª©ng vi√™n."
        
        if email_failed:
            message += f"\n\nKh√¥ng th·ªÉ g·ª≠i email ƒë·∫øn {len(email_failed)} ·ª©ng vi√™n: {', '.join(email_failed)}"
            
        if invalid_candidates:
            invalid_names = [c.get("ho_ten", "Kh√¥ng t√™n") for c in invalid_candidates]
            message += f"\n\nC√°c ·ª©ng vi√™n kh√¥ng ƒë·ªß ƒëi·ªÅu ki·ªán (ch∆∞a Pass CV): {', '.join(invalid_names)}"
        
        print(f"‚úÖ Ho√†n th√†nh ƒë·∫∑t l·ªãch ph·ªèng v·∫•n")
        return {
            "success": True,
            "valid_count": len(valid_candidates),
            "invalid_count": len(invalid_candidates),
            "email_success": len(email_success),
            "email_failed": len(email_failed),
            "message": message
        }
    except HTTPException:
        # ƒê√£ x·ª≠ l√Ω ·ªü tr√™n, ch·ªâ n√©m l·∫°i
        raise
    except Exception as e:
        print(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh: {str(e)}")
        import traceback
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"L·ªói server: {str(e)}")



@router.get("/stats")
def get_candidate_stats():
    stats = {
        "total": collection.count_documents({}),
        "by_status": {},
        "by_position": {},
        "by_month": {},  # Th√™m d√≤ng n√†y
        "scheduled_count": collection.count_documents({"lich_phong_van": {"$exists": True}}),
        "high_score_count": collection.count_documents({"diem_phu_hop": {"$gte": 80}})
    }

    # Th·ªëng k√™ theo tr·∫°ng th√°i
    status_list = collection.aggregate([
        {"$group": {"_id": "$ket_qua", "count": {"$sum": 1}}}
    ])
    for item in status_list:
        key = item["_id"] if item["_id"] else "Ch∆∞a ƒë√°nh gi√°"
        stats["by_status"][key] = item["count"]

    # Th·ªëng k√™ theo v·ªã tr√≠ ·ª©ng tuy·ªÉn
    position_list = collection.aggregate([
        {"$group": {"_id": "$vi_tri_ung_tuyen", "count": {"$sum": 1}}}
    ])
    for item in position_list:
        key = item["_id"] if item["_id"] else "Kh√¥ng r√µ"
        stats["by_position"][key] = item["count"]

    # Th·ªëng k√™ theo th√°ng t·ª´ tr∆∞·ªùng `ngay_nop` (ho·∫∑c `ngay_gui`)
    month_counts = defaultdict(int)
    for doc in collection.find({"ngay_nop": {"$exists": True}}):
        try:
            ngay = doc["ngay_nop"]
            if isinstance(ngay, str):
                ngay = datetime.fromisoformat(ngay)
            month_key = ngay.strftime("%Y-%m")
            month_counts[month_key] += 1
        except:
            continue

    stats["by_month"] = dict(sorted(month_counts.items()))  # S·∫Øp x·∫øp theo th√°ng

    return stats

@router.get("/summary")
def get_candidate_summary():
    

    today = datetime.now()
    this_month = datetime(today.year, today.month, 1)

    new_candidates = collection.count_documents({"ngay_nop": {"$gte": this_month}})
    interviewed = collection.count_documents({"trang_thai": {"$regex": "ph·ªèng v·∫•n", "$options": "i"}})
    results_sent = collection.count_documents({"trang_thai_gui_email": "ƒê√£ g·ª≠i"})

    return {
        "new_candidates": new_candidates,
        "interviewed": interviewed,
        "results_sent": results_sent
    }


@router.get("/lookup")
def lookup_candidate(phone: str = Query(...)):
    doc = collection.find_one({"so_dien_thoai": phone})
    if not doc:
        return {"found": False}
    return {
    "found": True,
    "ho_ten": doc.get("ho_ten", ""),
    "email": doc.get("email", ""),
    "so_dien_thoai": doc.get("so_dien_thoai", ""),
    "cccd": doc.get("cccd", ""),
    "ket_qua": doc.get("ket_qua", ""),
    "trang_thai": doc.get("trang_thai", "")
}

@router.delete("/{id}")
def delete_candidate(id: str):
    try:
        object_id = ObjectId(id)
    except errors.InvalidId:
        raise HTTPException(status_code=400, detail="ID kh√¥ng h·ª£p l·ªá")

    result = collection.delete_one({"_id": object_id})
    if result.deleted_count == 1:
        return {"success": True, "message": "ƒê√£ x√≥a ·ª©ng vi√™n th√†nh c√¥ng."}
    else:
        raise HTTPException(status_code=404, detail="Kh√¥ng t√¨m th·∫•y ·ª©ng vi√™n ƒë·ªÉ x√≥a")




@router.get("/{id}")
def get_candidate_by_id(id: str):
    try:
        object_id = ObjectId(id)
        doc = collection.find_one({"_id": object_id})
        if not doc:
            raise HTTPException(status_code=404, detail="Kh√¥ng t√¨m th·∫•y ·ª©ng vi√™n")
        doc["id"] = str(doc["_id"])
        del doc["_id"]
        return doc
    except errors.InvalidId:
        raise HTTPException(status_code=400, detail="ID kh√¥ng h·ª£p l·ªá")
    except Exception as e:
        print("‚ùå L·ªói khi l·∫•y ·ª©ng vi√™n theo ID:", e)
        raise HTTPException(status_code=500, detail="L·ªói server")


@router.patch("/{id}/update-result")
def update_candidate_result(id: str, result: str = Query(...)):
    try:
        object_id = ObjectId(id)
    except errors.InvalidId:
        print("‚ùå ID kh√¥ng h·ª£p l·ªá:", id)
        return {"error": "‚ùå Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t. ID ·ª©ng vi√™n kh√¥ng h·ª£p l·ªá."}

    candidate = collection.find_one({"_id": object_id})
    if not candidate:
        return {"error": "‚ùå Kh√¥ng t√¨m th·∫•y ·ª©ng vi√™n."}

    collection.update_one({"_id": object_id}, {"$set": {"ket_qua": result}})
    
    try:
        send_result_email(candidate["email"], candidate.get("ho_ten", ""), result)
    except Exception as e:
        print("‚ùå L·ªói g·ª≠i email:", e)

    candidate["ket_qua"] = result
    candidate["id"] = str(candidate["_id"])
    del candidate["_id"]
    return candidate

@router.put("/interviews/{interview_id}")
def update_interview(interview_id: str, data: dict = Body(...)):
    try:
        print(f"üîÑ C·∫≠p nh·∫≠t l·ªãch ph·ªèng v·∫•n cho ID: {interview_id}")
        print(f"üì¶ D·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c: {data}")
        
        # Chuy·ªÉn ƒë·ªïi ID th√†nh ObjectId
        try:
            object_id = ObjectId(interview_id)
        except errors.InvalidId:
            print(f"‚ùå ID kh√¥ng h·ª£p l·ªá: {interview_id}")
            raise HTTPException(status_code=400, detail="ID kh√¥ng h·ª£p l·ªá")
        
        # T√¨m ·ª©ng vi√™n
        candidate = collection.find_one({"_id": object_id})
        if not candidate:
            print(f"‚ùå Kh√¥ng t√¨m th·∫•y ·ª©ng vi√™n v·ªõi ID: {interview_id}")
            raise HTTPException(status_code=404, detail="Kh√¥ng t√¨m th·∫•y ·ª©ng vi√™n")
        
        # C·∫≠p nh·∫≠t th√¥ng tin l·ªãch ph·ªèng v·∫•n
        update_result = collection.update_one(
            {"_id": object_id},
            {"$set": {
                "lich_phong_van.ngay": data.get("date", ""),
                "lich_phong_van.gio": data.get("time", ""),
                "lich_phong_van.dia_diem": data.get("room", ""),
                "ho_ten": data.get("candidate", candidate.get("ho_ten", ""))
            }}
        )
        
        if update_result.modified_count == 0:
            print("‚ö†Ô∏è Kh√¥ng c√≥ thay ƒë·ªïi n√†o ƒë∆∞·ª£c √°p d·ª•ng")
            # V·∫´n tr·∫£ v·ªÅ th√†nh c√¥ng n·∫øu kh√¥ng c√≥ thay ƒë·ªïi
        
        # L·∫•y d·ªØ li·ªáu ƒë√£ c·∫≠p nh·∫≠t
        updated_candidate = collection.find_one({"_id": object_id})
        
        # Tr·∫£ v·ªÅ d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t theo ƒë·ªãnh d·∫°ng c·∫ßn thi·∫øt
        return {
            "id": str(updated_candidate["_id"]),
            "candidate": updated_candidate.get("ho_ten", ""),
            "date": updated_candidate.get("lich_phong_van", {}).get("ngay", ""),
            "time": updated_candidate.get("lich_phong_van", {}).get("gio", ""),
            "room": updated_candidate.get("lich_phong_van", {}).get("dia_diem", "")
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"‚ùå L·ªói khi c·∫≠p nh·∫≠t l·ªãch ph·ªèng v·∫•n: {str(e)}")
        import traceback
        print(traceback.format_exc())
        raise HTTPException(status_code=500, detail=f"L·ªói server: {str(e)}")


